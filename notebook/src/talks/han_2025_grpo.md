# Han 2025 - GRPO Example

[Notebook Tuning GPT-OSS](https://colab.research.google.com/github/unslothai/notebooks/blob/main/nb/gpt-oss-(20B)-GRPO.ipynb#scrollTo=MXPZ1MsUMqNZ)

This notebook shows how to finetune `gpt-oss-20b` using unsloth. The parameters used are:
```python
max_seq_length = 768
lora_rank = 4
lora_alpha = lora_rank * 2
load_in_4bit = True
offload_embedding = True
```

The toy problem is to induce gpt-oss to learn how to output an optimized all python `matmul` procedure that only uses the standard library. Naturally, using optimized libraries like `numpy` will be a lot faster, but there is some room to improve from a naive implementation in pure python.

First, we generate some random matrices. Note that we need `A_list` and `B_list` which are `list[list[float]]` to pass to our pure python function.
```python
import numpy as np
def generate_random_matrices(seed = 3407, n = 256):
    random_state = np.random.RandomState(seed)
    n, k, m = random_state.randint(1, n+1, size = 3)
    A = np.random.uniform(-10, 10, size = (n, k))
    B = np.random.uniform(-10, 10, size = (k, m))
    return A, A.tolist(), B, B.tolist()
```

For example, a kernel generated by GPT-5 is:
```python
# Kernel generated by GPT-5
def matmul(A, B):
    B_transpose = list(zip(*B))
    return [
        [
            sum(a*b for a, b in zip(row, col)) 
            for col in B_transpose
        ] for row in A
    ]
```

## Preventing Cheating

GRPO works using RL with a reward function. To get the desired behaviour, we have to find a reward function that disincentivises cheating. For example, the LLM might just come up with a solution that imports `torch` or `numpy` to get an optimized matmul function.

Firstly, we write a function called `check_only_stdlib_imports` that, given a string representing a python function (let's call it `fn_string`), checks if it imports anything outside of the python standard library. We omit the definition here as it is rather involved.

Secondly, given `fn_string`, we want to compile it into a python function and disallow the function from importing anything from the global name space. The following code does so:

```python
def create_locked_down_function(function: str):
    output_function = {}
    exec(function, {}, output_function)
    new_matmul = output_function["matmul"]
    new_matmul = types.FunctionType(new_matmul.__code__, {})
    return new_matmul
```

Some explanations:
- `exec(string: str, globals: dict, locals: dict)`
    - This executes code in `string` and stores whatever definitions within the code into `locals`
    - By specifying an empty `dict` for `globals`, we are disallowing the functions defined within to access the global namespace
- `types.FunctionType(code, globals)`
    - This creates a new function from compiled python bytecode
    - It also redefines the global variables that the function can access as an empty dictionary
- So this function turns `fn_string` into a python function, but disallows accessing any global variables and libraries



