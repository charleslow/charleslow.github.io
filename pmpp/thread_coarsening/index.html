<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CUDA Thread Coarsening Visualizer</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React and ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { font-family: 'Inter', sans-serif; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo } = React;

        // --- Icons (Replaces lucide-react import) ---
        const Layers = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="m12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83Z"/><path d="m22 17.65-9.17 4.16a2 2 0 0 1-1.66 0L2 17.65"/><path d="m22 12.65-9.17 4.16a2 2 0 0 1-1.66 0L2 12.65"/>
            </svg>
        );

        const Grid3X3 = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 9h18"/><path d="M3 15h18"/><path d="M9 3v18"/><path d="M15 3v18"/>
            </svg>
        );

        const Info = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/>
            </svg>
        );

        const ArrowRight = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M5 12h14"/><path d="m12 5 7 7-7 7"/>
            </svg>
        );

        // --- Main Component ---
        const MATRIX_SIZE = 8;

        // Helper to generate a dummy matrix
        const generateMatrix = (rows, cols, offset = 0) => {
            return Array.from({ length: rows }, (_, r) =>
                Array.from({ length: cols }, (_, c) => ((r * cols + c + offset) % 9) + 1)
            );
        };

        const ThreadCoarseningViz = () => {
            const [coarseningFactor, setCoarseningFactor] = useState(2);
            const [hoveredThread, setHoveredThread] = useState(null);
            
            // Matrix Data (static for visualization stability)
            const matrixA = useMemo(() => generateMatrix(MATRIX_SIZE, MATRIX_SIZE, 0), []);
            const matrixB = useMemo(() => generateMatrix(MATRIX_SIZE, MATRIX_SIZE, 3), []);
            
            // Calculate Matrix C dimensions based on A and B (it's square here)
            const matrixC = useMemo(() => {
                const result = Array.from({ length: MATRIX_SIZE }, () => Array(MATRIX_SIZE).fill(0));
                for (let i = 0; i < MATRIX_SIZE; i++) {
                    for (let j = 0; j < MATRIX_SIZE; j++) {
                        for (let k = 0; k < MATRIX_SIZE; k++) {
                            result[i][j] += matrixA[i][k] * matrixB[k][j];
                        }
                    }
                }
                return result;
            }, [matrixA, matrixB]);
            
            // Calculate which thread owns a specific cell (row, col)
            const getThreadID = (r, c) => {
                const threadCol = Math.floor(c / coarseningFactor);
                return { tr: r, tc: threadCol, id: `${r}-${threadCol}` };
            };

            const handleMouseEnter = (r, c) => {
                const { id } = getThreadID(r, c);
                setHoveredThread(id);
            };

            const handleMouseLeave = () => {
                setHoveredThread(null);
            };

            const isCellOwnedByHoveredThread = (r, c) => {
                if (!hoveredThread) return false;
                const { id } = getThreadID(r, c);
                return id === hoveredThread;
            };

            // Explanation text based on state
            const getExplanation = () => {
                if (!hoveredThread) return "Hover over the Result Matrix (C) to see thread responsibility.";
                
                const [tr, tc] = hoveredThread.split('-').map(Number);
                const startCol = tc * coarseningFactor;
                const endCol = Math.min(startCol + coarseningFactor - 1, MATRIX_SIZE - 1);
                
                return (
                    <span>
                        <strong>Thread ({tc}, {tr})</strong> is active. <br/>
                        It is responsible for calculating <strong>{endCol - startCol + 1} elements</strong> in Matrix C: <br/>
                        <span className="text-blue-600 font-mono">C[{tr}][{startCol}]</span> through <span className="text-blue-600 font-mono">C[{tr}][{endCol}]</span>.
                        <br/>
                        To do this, it loads <strong>Row {tr}</strong> from A and <strong>Columns {startCol}-{endCol}</strong> from B.
                    </span>
                );
            };

            return (
                <div className="flex flex-col h-screen bg-gray-50 text-gray-800 font-sans overflow-hidden">
                    {/* Header */}
                    <header className="bg-slate-900 text-white p-4 shadow-md flex justify-between items-center shrink-0">
                        <div className="flex items-center gap-2">
                            <Layers className="text-blue-400" />
                            <h1 className="text-xl font-bold tracking-tight">CUDA Thread Coarsening Visualizer</h1>
                        </div>
                        <div className="text-sm text-slate-400">
                            Visualize how one thread computes multiple output elements
                        </div>
                    </header>

                    <main className="flex-1 flex overflow-hidden">
                        {/* Left Control Panel */}
                        <aside className="w-80 bg-white border-r border-gray-200 p-6 flex flex-col gap-6 overflow-y-auto shadow-sm z-10">
                            
                            {/* Controls */}
                            <div className="space-y-4">
                                <h2 className="text-sm font-semibold text-gray-500 uppercase tracking-wider flex items-center gap-2">
                                    <Grid3X3 size={16} /> Configuration
                                </h2>
                                
                                <div className="bg-slate-50 p-4 rounded-lg border border-slate-200">
                                    <label className="block text-sm font-medium text-gray-700 mb-2">
                                        Coarsening Factor: <span className="text-blue-600 font-bold">{coarseningFactor}</span>
                                    </label>
                                    <input 
                                        type="range" 
                                        min="1" 
                                        max="4" 
                                        step="1"
                                        value={coarseningFactor}
                                        onChange={(e) => setCoarseningFactor(Number(e.target.value))}
                                        className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600"
                                    />
                                    <div className="flex justify-between text-xs text-gray-400 mt-1">
                                        <span>1 (Naive)</span>
                                        <span>4 (High)</span>
                                    </div>
                                    <p className="text-xs text-gray-500 mt-3 italic">
                                        A factor of {coarseningFactor} means each thread calculates {coarseningFactor} horizontally adjacent output cells.
                                    </p>
                                </div>
                            </div>

                            {/* Info / Logic */}
                            <div className="space-y-3">
                                <h2 className="text-sm font-semibold text-gray-500 uppercase tracking-wider flex items-center gap-2">
                                    <Info size={16} /> Logic
                                </h2>
                                <div className="bg-blue-50 border border-blue-100 p-4 rounded-lg text-sm text-blue-900 leading-relaxed">
                                    {getExplanation()}
                                </div>
                            </div>

                            {/* Code Snippet */}
                            <div className="flex-1 flex flex-col min-h-[200px]">
                                <h2 className="text-sm font-semibold text-gray-500 uppercase tracking-wider mb-2">Pseudo-CUDA Kernel</h2>
                                <div className="flex-1 bg-slate-900 text-slate-300 p-4 rounded-lg font-mono text-xs overflow-auto shadow-inner">
                                    <pre>{`
__global__ void matMulCoarsened(
    float* A, float* B, float* C, 
    int N) 
{
  // Calculate global row index
  int row = blockIdx.y * blockDim.y 
            + threadIdx.y;
            
  // Calculate base col index for thread
  int colBase = (blockIdx.x * blockDim.x 
                + threadIdx.x) 
                * ${coarseningFactor}; // FACTOR

  if (row < N && colBase < N) {
    
    // Registers for accumulation
    float sum[${coarseningFactor}]; 
    
    // Initialize
    for (int i=0; i < ${coarseningFactor}; i++) 
       sum[i] = 0.0f;

    // THE LOOP
    for (int k = 0; k < N; k++) {
      float a_val = A[row * N + k];
      
      // Compute multiple outputs
      // Reuse 'a_val' ${coarseningFactor} times!
      for (int i=0; i < ${coarseningFactor}; i++) {
         if (colBase + i < N) {
           sum[i] += a_val * B[k * N + (colBase + i)];
         }
      }
    }

    // Write back
    for (int i=0; i < ${coarseningFactor}; i++) {
       if (colBase + i < N)
         C[row * N + colBase + i] = sum[i];
    }
  }
}
                                    `}</pre>
                                </div>
                            </div>

                        </aside>

                        {/* Visualization Area */}
                        <div className="flex-1 bg-slate-50 p-8 overflow-y-auto flex flex-col items-center justify-center">
                            
                            {/* Top Row: A and B */}
                            <div className="flex gap-12 mb-12">
                                
                                {/* Matrix A */}
                                <div className="flex flex-col items-center">
                                    <h3 className="mb-2 font-bold text-gray-700">Matrix A (Inputs)</h3>
                                    <div className="grid gap-1" style={{ gridTemplateColumns: `repeat(${MATRIX_SIZE}, minmax(0, 1fr))` }}>
                                        {matrixA.map((row, rIndex) => (
                                            row.map((val, cIndex) => {
                                                // Logic to highlight row of A if corresponding thread is hovered
                                                let isActive = false;
                                                if (hoveredThread) {
                                                    const [tr, tc] = hoveredThread.split('-').map(Number);
                                                    if (rIndex === tr) isActive = true; 
                                                }

                                                return (
                                                    <div 
                                                        key={`a-${rIndex}-${cIndex}`}
                                                        className={`
                                                            w-8 h-8 flex items-center justify-center text-xs border rounded transition-colors duration-200
                                                            ${isActive 
                                                                ? 'bg-green-100 border-green-500 text-green-900 font-bold shadow-sm scale-110 z-10' 
                                                                : 'bg-white border-gray-200 text-gray-300'}
                                                        `}
                                                    >
                                                        {val}
                                                    </div>
                                                );
                                            })
                                        ))}
                                    </div>
                                    <div className="mt-2 text-xs text-green-700 font-medium h-4">
                                        {hoveredThread ? `Loading Row ${hoveredThread.split('-')[0]} (Reused)` : ''}
                                    </div>
                                </div>

                                {/* Operator */}
                                <div className="flex items-center justify-center text-gray-400 font-bold text-2xl">Ã—</div>

                                {/* Matrix B */}
                                <div className="flex flex-col items-center">
                                    <h3 className="mb-2 font-bold text-gray-700">Matrix B (Inputs)</h3>
                                    <div className="grid gap-1" style={{ gridTemplateColumns: `repeat(${MATRIX_SIZE}, minmax(0, 1fr))` }}>
                                        {matrixB.map((row, rIndex) => (
                                            row.map((val, cIndex) => {
                                                // Logic to highlight columns of B
                                                let isActive = false;
                                                if (hoveredThread) {
                                                    const [tr, tc] = hoveredThread.split('-').map(Number);
                                                    const startCol = tc * coarseningFactor;
                                                    const endCol = startCol + coarseningFactor;
                                                    if (cIndex >= startCol && cIndex < endCol) isActive = true;
                                                }

                                                return (
                                                    <div 
                                                        key={`b-${rIndex}-${cIndex}`}
                                                        className={`
                                                            w-8 h-8 flex items-center justify-center text-xs border rounded transition-colors duration-200
                                                            ${isActive 
                                                                ? 'bg-purple-100 border-purple-500 text-purple-900 font-bold shadow-sm scale-105 z-10' 
                                                                : 'bg-white border-gray-200 text-gray-300'}
                                                        `}
                                                    >
                                                        {val}
                                                    </div>
                                                );
                                            })
                                        ))}
                                    </div>
                                    <div className="mt-2 text-xs text-purple-700 font-medium h-4">
                                        {hoveredThread ? `Loading Cols` : ''}
                                    </div>
                                </div>
                            </div>

                            {/* Arrow */}
                            <div className="mb-8 text-gray-400 rotate-90 lg:rotate-0">
                                <ArrowRight size={32} />
                            </div>

                            {/* Bottom Row: C */}
                            <div className="flex flex-col items-center">
                                <h3 className="mb-2 font-bold text-gray-700 flex items-center gap-2">
                                    Matrix C (Result) 
                                    <span className="text-xs font-normal text-blue-600 bg-blue-50 px-2 py-0.5 rounded-full border border-blue-100">
                                        Interactive Area
                                    </span>
                                </h3>
                                
                                <div 
                                    className="grid gap-1 relative p-2 border-2 border-dashed border-gray-200 rounded-xl bg-white" 
                                    style={{ gridTemplateColumns: `repeat(${MATRIX_SIZE}, minmax(0, 1fr))` }}
                                >
                                    {matrixC.map((row, rIndex) => (
                                        row.map((val, cIndex) => {
                                            const isActive = isCellOwnedByHoveredThread(rIndex, cIndex);
                                            
                                            // Calculate border styling for "chunking" visualization
                                            const threadCol = Math.floor(cIndex / coarseningFactor);
                                            const isStartOfChunk = cIndex % coarseningFactor === 0;
                                            const isEndOfChunk = (cIndex + 1) % coarseningFactor === 0 || cIndex === MATRIX_SIZE - 1;

                                            return (
                                                <div 
                                                    key={`c-${rIndex}-${cIndex}`}
                                                    onMouseEnter={() => handleMouseEnter(rIndex, cIndex)}
                                                    onMouseLeave={handleMouseLeave}
                                                    className={`
                                                        w-10 h-10 flex items-center justify-center text-sm border cursor-pointer transition-all duration-150
                                                        ${isActive 
                                                            ? 'bg-blue-500 border-blue-600 text-white font-bold shadow-lg scale-110 z-20' 
                                                            : 'bg-slate-50 border-slate-200 text-slate-500 hover:bg-slate-100'}
                                                        ${isStartOfChunk ? 'rounded-l-md border-l-2' : ''}
                                                        ${isEndOfChunk ? 'rounded-r-md border-r-2' : ''}
                                                    `}
                                                >
                                                    {val}
                                                </div>
                                            );
                                        })
                                    ))}
                                </div>
                                <div className="mt-4 text-center max-w-lg text-sm text-gray-500">
                                    Hover over cells above. Notice how one thread (blue highlight) handles multiple adjacent columns.
                                    This reduces the total number of threads launched by a factor of {coarseningFactor}.
                                </div>
                            </div>
                        </div>
                    </main>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ThreadCoarseningViz />);
    </script>
</body>
</html>